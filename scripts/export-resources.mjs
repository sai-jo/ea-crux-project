#!/usr/bin/env node
/**
 * Export Resources Script
 *
 * Exports sources from SQLite database to split resource files.
 * Merges with existing YAML to preserve manual edits.
 *
 * Usage:
 *   node scripts/export-resources.mjs           # Export cited sources
 *   node scripts/export-resources.mjs --all     # Export all sources
 *   node scripts/export-resources.mjs --dry-run # Preview changes
 */

import { readFileSync, writeFileSync, existsSync, readdirSync, mkdirSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import { parse, stringify } from 'yaml';
import Database from 'better-sqlite3';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const PROJECT_ROOT = join(__dirname, '..');

const DB_PATH = join(PROJECT_ROOT, '.cache', 'knowledge.db');
const RESOURCES_DIR = join(PROJECT_ROOT, 'src', 'data', 'resources');

// Forum publication IDs that go in forums.yaml
const FORUM_PUBLICATION_IDS = new Set(['lesswrong', 'alignment-forum', 'ea-forum']);

// Parse CLI args
const args = process.argv.slice(2);
const includeAll = args.includes('--all');
const dryRun = args.includes('--dry-run');
const verbose = args.includes('--verbose');

// =============================================================================
// DATABASE ACCESS
// =============================================================================

function getDatabase() {
  if (!existsSync(DB_PATH)) {
    console.error('Database not found. Run "npm run kb:scan" first.');
    process.exit(1);
  }
  return new Database(DB_PATH, { readonly: true });
}

/**
 * Get all sources with their citation info and summaries
 */
function getSourcesFromDb(db, onlyCited = true) {
  const query = onlyCited
    ? `
      SELECT DISTINCT
        s.id,
        s.url,
        s.title,
        s.authors,
        s.year,
        s.source_type,
        s.content_path,
        s.fetch_status,
        s.fetched_at,
        sm.one_liner,
        sm.summary,
        sm.review,
        sm.key_points
      FROM sources s
      JOIN article_sources ars ON s.id = ars.source_id
      LEFT JOIN summaries sm ON s.id = sm.entity_id AND sm.entity_type = 'source'
      ORDER BY s.title
    `
    : `
      SELECT
        s.id,
        s.url,
        s.title,
        s.authors,
        s.year,
        s.source_type,
        s.content_path,
        s.fetch_status,
        s.fetched_at,
        sm.one_liner,
        sm.summary,
        sm.review,
        sm.key_points
      FROM sources s
      LEFT JOIN summaries sm ON s.id = sm.entity_id AND sm.entity_type = 'source'
      ORDER BY s.title
    `;

  return db.prepare(query).all();
}

/**
 * Get articles that cite a source
 */
function getCitingArticles(db, sourceId) {
  return db
    .prepare(
      `
    SELECT article_id FROM article_sources WHERE source_id = ?
  `
    )
    .all(sourceId)
    .map((r) => r.article_id);
}

// =============================================================================
// YAML OPERATIONS
// =============================================================================

/**
 * Determine which file a resource belongs to based on type/publication
 */
function getResourceCategory(resource) {
  if (resource.type === 'paper') return 'papers';
  if (resource.type === 'government') return 'government';
  if (resource.publication_id && FORUM_PUBLICATION_IDS.has(resource.publication_id)) return 'forums';
  return 'general';
}

/**
 * Load existing resources from split directory
 */
function loadExistingResources() {
  const resources = [];
  if (!existsSync(RESOURCES_DIR)) {
    return resources;
  }

  const files = readdirSync(RESOURCES_DIR).filter((f) => f.endsWith('.yaml'));
  for (const file of files) {
    const filepath = join(RESOURCES_DIR, file);
    const content = readFileSync(filepath, 'utf-8');
    const data = parse(content) || [];
    resources.push(...data);
  }
  return resources;
}

/**
 * Save resources to the appropriate split files based on type
 */
function saveResources(resources) {
  // Ensure directory exists
  if (!existsSync(RESOURCES_DIR)) {
    mkdirSync(RESOURCES_DIR, { recursive: true });
  }

  // Categorize resources
  const categorized = {
    papers: [],
    government: [],
    forums: [],
    general: [],
  };

  for (const resource of resources) {
    const category = getResourceCategory(resource);
    categorized[category].push(resource);
  }

  // Headers for each file
  const headers = {
    papers: `# Papers Resources
# Academic papers, preprints, and research publications
# Auto-generated by: node scripts/export-resources.mjs
# Last exported: ${new Date().toISOString()}

`,
    government: `# Government Resources
# Government documents, policy reports, and regulatory materials
# Auto-generated by: node scripts/export-resources.mjs
# Last exported: ${new Date().toISOString()}

`,
    forums: `# Forums Resources
# Posts from LessWrong, Alignment Forum, and EA Forum
# Auto-generated by: node scripts/export-resources.mjs
# Last exported: ${new Date().toISOString()}

`,
    general: `# General Resources
# Web articles, blog posts, and other resources
# Auto-generated by: node scripts/export-resources.mjs
# Last exported: ${new Date().toISOString()}

`,
  };

  // Write each category to its file
  for (const [category, items] of Object.entries(categorized)) {
    const filepath = join(RESOURCES_DIR, `${category}.yaml`);
    const content = headers[category] + stringify(items, { lineWidth: 100 });
    writeFileSync(filepath, content);
    console.log(`  ${category}.yaml: ${items.length} resources`);
  }
}

/**
 * Generate a human-readable ID from title and year
 */
function generateReadableId(title, year) {
  if (!title) return null;

  // Extract first few meaningful words
  const words = title
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, '')
    .split(/\s+/)
    .filter((w) => w.length > 2 && !['the', 'and', 'for', 'with', 'from'].includes(w))
    .slice(0, 3);

  if (words.length === 0) return null;

  const slug = words.join('-');
  return year ? `${slug}-${year}` : slug;
}

/**
 * Convert DB source to YAML resource format
 */
function dbSourceToResource(dbSource, citedBy) {
  const resource = {
    id: dbSource.id,
    url: dbSource.url,
    title: dbSource.title || 'Untitled',
    type: dbSource.source_type || 'web',
  };

  // Parse authors JSON
  if (dbSource.authors) {
    try {
      const authors = JSON.parse(dbSource.authors);
      if (Array.isArray(authors) && authors.length > 0) {
        resource.authors = authors;
      }
    } catch {
      // Ignore parse errors
    }
  }

  // Add published date
  if (dbSource.year) {
    resource.published_date = String(dbSource.year);
  }

  // Add local filename if fetched
  if (dbSource.content_path) {
    resource.local_filename = dbSource.content_path;
  }

  // Add AI-generated fields if available
  // Some summaries are stored as JSON objects with {oneLiner, summary, review, keyPoints}
  if (dbSource.summary) {
    let summary = dbSource.summary;
    let review = dbSource.review;
    let keyPoints = null;

    // Check if summary looks like a JSON object with our expected fields
    // Some entries have preamble text like "Based on the source document..." before the JSON
    const trimmedSummary = summary.trim();
    const jsonStart = trimmedSummary.indexOf('{');
    const hasJsonStructure = jsonStart !== -1 && trimmedSummary.includes('"summary"');

    if (hasJsonStructure) {
      // Extract just the JSON portion (from first { to end)
      const jsonPortion = trimmedSummary.slice(jsonStart);

      // Extract fields using regex (handles malformed JSON with unescaped newlines)
      // The JSON has structure: {"oneLiner": "...", "summary": "...", "review": "...", "keyPoints": [...]}
      // We use non-greedy matching with lookahead to find field boundaries
      const extractField = (json, field) => {
        // Match "field": "value" where value ends at quote followed by comma/whitespace and next field or }
        const pattern = new RegExp(`"${field}"\\s*:\\s*"([\\s\\S]*?)"\\s*,?\\s*(?="[a-zA-Z]|\\}|$)`);
        const match = json.match(pattern);
        if (match) return match[1].replace(/\s+/g, ' ').trim();
        return null;
      };

      const extractedSummary = extractField(jsonPortion, 'summary');
      const extractedOneLiner = extractField(jsonPortion, 'oneLiner');
      const extractedReview = extractField(jsonPortion, 'review');

      if (extractedSummary || extractedOneLiner) {
        summary = extractedSummary || extractedOneLiner;
      }
      if (extractedReview) {
        review = review || extractedReview;
      }

      // Try to extract keyPoints array
      const keyPointsMatch = jsonPortion.match(/"keyPoints"\s*:\s*\[([\s\S]*?)\]/);
      if (keyPointsMatch) {
        const pointsStr = keyPointsMatch[1];
        const points = pointsStr.match(/"([^"]+)"/g);
        if (points) {
          keyPoints = points.map(p => p.replace(/"/g, '').trim()).filter(Boolean);
        }
      }
    }

    if (summary) {
      resource.summary = summary;
    }
    if (review) {
      resource.review = review;
    }
    if (keyPoints && Array.isArray(keyPoints) && keyPoints.length > 0) {
      resource.key_points = keyPoints;
    }
  }

  // Also check standalone review field
  if (!resource.review && dbSource.review) {
    resource.review = dbSource.review;
  }

  // Add key points if available (from separate column)
  if (!resource.key_points && dbSource.key_points) {
    try {
      const points = JSON.parse(dbSource.key_points);
      if (Array.isArray(points) && points.length > 0) {
        resource.key_points = points;
      }
    } catch {
      // Ignore parse errors
    }
  }

  // Add cited_by references
  if (citedBy && citedBy.length > 0) {
    resource.cited_by = citedBy;
  }

  // Add fetched_at if available
  if (dbSource.fetched_at) {
    resource.fetched_at = dbSource.fetched_at;
  }

  return resource;
}

/**
 * Merge DB resources with existing YAML (preserves manual edits)
 */
function mergeResources(dbResources, existingResources) {
  const existingById = new Map(existingResources.map((r) => [r.id, r]));
  const merged = [];
  const newCount = { added: 0, updated: 0, preserved: 0 };

  for (const dbResource of dbResources) {
    const existing = existingById.get(dbResource.id);

    if (existing) {
      // Merge: DB fields update, but preserve manual additions
      // Helper to check if a value is meaningfully set (not null/undefined/empty array)
      const hasValue = (v) => v !== null && v !== undefined && !(Array.isArray(v) && v.length === 0);

      const mergedResource = {
        ...existing,
        // Update from DB (these are authoritative)
        url: dbResource.url || existing.url,
        title: dbResource.title || existing.title,
        type: dbResource.type || existing.type,
        cited_by: dbResource.cited_by || existing.cited_by,
        // Prefer DB values for these if DB has them, otherwise keep existing
        authors: hasValue(dbResource.authors) ? dbResource.authors : existing.authors,
        published_date: hasValue(dbResource.published_date) ? dbResource.published_date : existing.published_date,
        summary: hasValue(dbResource.summary) ? dbResource.summary : existing.summary,
        review: hasValue(dbResource.review) ? dbResource.review : existing.review,
        key_points: hasValue(dbResource.key_points) ? dbResource.key_points : existing.key_points,
        local_filename: dbResource.local_filename || existing.local_filename,
        fetched_at: dbResource.fetched_at || existing.fetched_at,
      };
      merged.push(mergedResource);
      existingById.delete(dbResource.id);
      newCount.updated++;
    } else {
      // New resource from DB
      merged.push(dbResource);
      newCount.added++;
    }
  }

  // Keep resources that are only in YAML (manual entries)
  for (const [id, resource] of existingById) {
    merged.push(resource);
    newCount.preserved++;
  }

  return { merged, stats: newCount };
}

// =============================================================================
// MAIN
// =============================================================================

function main() {
  console.log('Exporting resources from SQLite to YAML...\n');

  const db = getDatabase();

  // Get sources from database
  const dbSources = getSourcesFromDb(db, !includeAll);
  console.log(`Found ${dbSources.length} sources in database${includeAll ? '' : ' (cited only)'}`);

  // Convert to resource format with citing articles
  const dbResources = dbSources.map((source) => {
    const citedBy = getCitingArticles(db, source.id);
    return dbSourceToResource(source, citedBy);
  });

  // Load existing YAML
  const existingResources = loadExistingResources();
  console.log(`Found ${existingResources.length} existing resources in YAML`);

  // Merge
  const { merged, stats } = mergeResources(dbResources, existingResources);

  console.log(`\nMerge results:`);
  console.log(`  Added: ${stats.added}`);
  console.log(`  Updated: ${stats.updated}`);
  console.log(`  Preserved (manual): ${stats.preserved}`);
  console.log(`  Total: ${merged.length}`);

  if (dryRun) {
    console.log('\n[DRY RUN] Would write to:', RESOURCES_DIR);
    if (verbose) {
      console.log('\nPreview (first 3 resources):');
      console.log(stringify(merged.slice(0, 3)));
    }
    return;
  }

  // Sort by title for consistent output
  merged.sort((a, b) => (a.title || '').localeCompare(b.title || ''));

  // Write to split files
  console.log('\nWriting to split files:');
  saveResources(merged);

  console.log(`\nâœ“ Written to: ${RESOURCES_DIR}/`);

  db.close();
}

main();
